> ls: lista archivos
- “-l”: fuerza salida para que sea una entrada por línea. 
El primer caracter por cada fila indicará si es un archivo (“-”), directorio (“d”) o link (“l”).
El siguiente grupo de 3 caracteres son los permisos que tiene el propietario
El siguiente grupo de 3 caracteres son los permisos que tiene el grupo al que pertenece el propietario
El siguiente grupo de 3 caracteres son los permisos que tiene el resto
El siguiente carácter no sé xD
La siguiente columna el nombre del usuario propietario
La siguiente columna el nombre del grupo al que pertenece el propietario
- “-R“: Lista recursiva de los sub-directorios encontrados 
- “-a”: incluye directorios y archivos cuyo nombre empieza con punto “.” (ocultos)
- “-h“: se debe usar con “-l”. Muestra los sufijos en la columna de tamaño para reducir los dígitos de esta información a 2 o 3. Por ejemplo. En lugar de mostrar “11875” (bytes), mostrará “12K”.
- “*”: comodín que se puede usar al inicio y/o final del valor indicado, para listar los archivos / directorios
cuyo nombre contenta el valor indicado. Ejemplo: ls -l *.log

> cp: copia archivos 
- “-R”: si se indica un directorio entonces copia este con toda su estructura interna

> mv: mueve archivos / directorios

> touch: por defecto cambia el tiempo de modificación y acceso de un archivo. En caso no exista lo crea con los permisos x defecto.
- “-r”: usa el tiempo de acceso y modificación del archivo especificado en lugar del tiempo actual
- “-a”: cambia el tiempo de acceso del archivo. el tiempo de modificación no será cambiado a menos que se indique el flag “-m“
- “-m”: cambia el tiempo de modificación del archivo. el tiempo de acceso no será cambiado a menos que se indique el flag “-a“
- “-c”: no crea el archivo si no existe. No se muestra error de mensaje
- “-A”: ajusta el tiempo (timestamp) de modificación y acceso de un archivo. Se debe indicar de la siguiente forma: [-][[hh]mm]SS:
“-“: hace el ajuste negativo. El nuevo timestamp será anterior al actual
“hh”: número de horas. de 00 a 99
“mm”: número de minutos. de 00 a 59
“SS”: número de segundos. de 00 a 59
Este comando implica el flag “-c”, ya que si el archivo especificado no existe entonces la ejecución será ignorada sin arrojar error.
- “-t”: cambia el tiempo de acceso y modificación al tiempo especificado en lugar del tiempo actual. Se debe indicar de la siguiente forma: [[CC]YY]MMDDhhmm[.SS]:
“CC”: Los primeros 2 dígitos del año  (el siglo)    
“YY”: Los segundos 2 dígitos del año. 
“MM”: Mes del año. De 01 a 12
“DD”: Día del mes. De 01 a 31
“hh”: Hora del día. De 00 a 23
“mm”: Minuto de hora. De 00 a 59
“SS”: Segundos de minuto. De 00 a 61
Si “YY” es especificado, pero “CC” no, entonces un valor entre 69 - 99 dado a “YY”, “CC” tendrá el valor “19”. En caso no sea así, “CC” tendrá el valor de “20”.
Si “CC” y “YY” no son especificados, los valores por defecto se obtendrán del año actual. 
Si “SS” no es especificada, el valor x defecto es 0
Ejemplo: touch -t 200706302035.12 ARCHIVO 
Fecha equivalente: Jun 30 20:35:12 2007
          
> cd: cambia de directorio 

> pwd: print working directory. muestra la ruta del directorio actual

> pushd: almacena el directorio actual en una pila (como un portapapeles en la ventana de comandos) y luego realiza lo mismo que el comando “cd” a la ruta indicada

> popd extrae y elimina el último directorio de la pila y efectúa un “cd” sobre este

> man: muestra un manual / guía del comando indicado

> rm: elimina los directorio(s) / archivo(s) indicados:
- “-f”: fuerza la eliminación (ignora los archivos y argumentos inexistentes. No pregunta) independientemente de los permisos del archivo. Si el archivo no existe, no muestra un mensaje de diagnóstico ni modifica el estado de salida para reflejar un error. Anula cualquier flag “-f“ previo 
- “-i”: solicita confirmación antes de eliminar cada archivo. Anula cualquier flag “-f“ previo 
- “-d”: intenta remover directorios y otro tipo de archivos
- “-r” / “-R“: Intenta eliminar la jerarquía de archivos enraizada en cada archivo
Implica el flag “-d”

> more / less: muestra el contenido de un archivo desde el inicio
- barra espaciadora: salta a siguiente hoja
- enter: scrolea N líneas. x defecto N es igual a 1
- tecla d: scrolea haca atrás N líneas
- tecla b: scrolea haca adelante N líneas
- “-n”: número de líneas, comenzando por la última (no aplica para less)


> tail: muestra el contenido desde el final de los archivos indicados
- “-n”: número de líneas, comenzando por la última
- “-f”: Permite que se cree un loop en búsqueda de nuevos datos al final de los archivos indicados y cuando se encuentren se imprimirán

> cat: concatena e imprime un archivo

> which: muestra la ruta de los programas indicados. 
- Ejemplo: which python python3 npm…
- Resultado: 
/Users/marlorebazaloyola/anaconda3/bin/python
/Users/marlorebazaloyola/anaconda3/bin/python3
/usr/local/bin/npm

> alias: permite asociar un comando o grupo de comandos a una cadena
- Sintaxis: alias CUALQUIER_NOMBRE=“COMANDO…”
Luego de eso el alias indicado se podrá ejecutar como un comando cualquiera. Lo que se indique después de este, será concatenado al contenido del alias.
Ejemplo: 
$ alias mld="ls -lha”
$ mld mi_directorio 


> echo: Muestra los operandos indicados, separados por un espacio en blanco seguidos de un salto de línea final
- “-n”: no imprime el caracter final de salto de línea
Se puede aprovechar para mostrar los valores de las variables de entorno.
- Ejemplo: echo -n $PATH $MONGO_PATH $CONDA_PREFIX
- Resultado:
/Users/marlorebazaloyola/anaconda3/bin:/Users/marlorebazaloyola/anaconda3/condabin:/Library/Frameworks/Python.framework/Versions/3.7/bin:/Library/Frameworks/Python.framework/Versions/3.7/bin:/Library/Frameworks/Python.framework/Versions/3.5/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/Applications/mongodb/bin /Applications/mongodb /Users/marlorebazaloyola/anaconda3

> ~/.bash_profile: Archivo de configuración para configurar el entorno de usuario. Puede ser modificado y agregar cualquier configuración adicional. Se ejecuta cada vez que un usuario abre una terminal (o se logea al sistema). En mac se llama de esta forma, puede que en otras distribuciones linux se llame de otra forma.

> export: crea o modifica el valor de una variable de entorno en la sesión actual de la interfaz de linea de comandos (shell)
- si se ejecuta sin argumentos lista todas las variables exportadas
- “-f”: indica que lo que se está exportando es una función, si no se indica asume que es una variable lo que se está exportando
- Ejemplo exportando una función y ejecutándola:
$ my_function() { echo 'hola soy cara!'; }
$ export -f my_function 
$ my_function
$ hola soy cara!

> signo mayor “>” (Estándar output / error): Permite indicar la salida del estándar output y error al ejecutar un comando. Por defecto hace referencia al estándar output y si no existe crea el archivo, en caso exista sobreescribe su contenido.
- “1>”: hace referencia a la primera variable que es el resultado del estándar output
- “2>”: hace referencia a la segunda variable que es el resultado del estándar error
- “>>”: permite indicar que la salida se agregue al archivo después de su última línea y no sobre-escriba el contenido
Nota:
- Ejemplo de ejecución: python runMe.py 1>> salida 2>> error
- Enviar el stdout y stderror al mismo archivo: python runMe.py > todo.log 2>&1
“&1” hace referencia al primer parámetro, es decir a “todo.log”. 
Es equivalente a: python runMe.py > todo.log 2> todo.log
En caso se quiera agregar la data y no sobre escribirla completamente, bastará con agregar un signo mayor solamente al primer argumento (No al segundo), ejemplo: python runMe.py >> todo.log 2> todo.log

> signo menor “<” (Estándar input): Permite indicar un archivo como entrada al ejecutar un comando
Ejemplo, ejecutamos script sql: mysql -u root -p < script.sql (el password es “mysql” xD)

> | : (pipe) barra vertical o palote, se utiliza para canalizar un comando a otro. Es decir, dirige la salida del primer comando a la entrada del segundo comando.
Ejemplo 1: 
cat script.sql | mysql -u root -p ( Es similar a ejecutar: mysql -u root -p < script.sql. La diferencia es que con el signo “<” debe especificarse un archivo como entrada)
Ejemplo 2:
cat data.csv | grep lo | awk -F "," '{
split($5, a, "|"); 
values="";
for (i=1; i<=length(a); i++) {
if (i == length(a)) {
values=values a[i];
} else {
values=values a[i] ",";
}
}
printf("%s tiene %s años y le gusta: %s.\n", $2, $4, values);
}' | grep -v Lolo | less


> Procesos:
1. top: comando que muestra y actualiza información ordenada de los procesos en ejecución.
- “q”: presionando esta tecla salimos de la lista
- “o”: presionando esta tecla, nos permite ingresar la llave de una columna del listado de procesos para poder
ordenarlos de mayor a menor por este criterio
2. kill -9 [PID]: Mata (distinto a finalizar) el proceso con el identificador indicado.
3. “ &”: espacio + “&” al final de un comando, lo ejecuta en background en la terminal. 
Luego de ejecutarlo en background, se muestra su PID.
4. control + C: No mata un proceso, sino que lo finaliza.
5. Cuando se mata un proceso de un comando en la misma terminal en la que se ejecutó en background, se muestra en la salida el comando tal como se ejecutó
6. DATO: No cometer el error de ejecutar un comando en background que arroje salida, sin pasarle argumentos de estandar de salida y error, ya que escribirá la salida en el mismo propmt donde se quiere escribir otros comandos.
Ejemplo de comando: python runMe.py 5 &
Para solucionarlo se tendrá que matar el proceso desde otra terminal.
7. Ejecutar secuencia de procesos: se debe añadir un punto y coma “;”
Ejemplo: python runMe.py 4; echo “Hi mundo”; python runMe.py 10
Esto permite ejecutar el siguiente proceso luego de que finalice o se mate el anterior

> ps: Muestra el estado de todos los procesos que se están ejecutando
- “aux” (sin guión): Muestra a detalle todos los procesos en el sistema en un formato orientado al usuario. FUENTE: https://www.linuxito.com/gnu-linux/nivel-alto/38-ps-aux-explicado
- “-w”: Amplia el ancho de salida en donde se muestra la información. (Por defecto el tamaño de la ventana actual)
- “-A”: Muestra la información de los procesos de otros usuarios.

> wc: Cuenta el número de palabra, líneas, caracteres y/o bytes de los archivos indicados
- “-c”: cuenta el número de bytes. Cancela cualquier uso previo de la opción “-m“
- “-l”: cuenta el número de líneas
- “-m“: cuenta el número de caracteres. Si el entorno local actual no admite caracteres multibyte, esto es equivalente a la opción “-c”. Cancela cualquier uso previo de la opción “-c”.
- “-w“: cuenta el número de palabras
- Ejemplo: wc -l todo.log, salida: 16 todo.log => 16 líneas
- También se puede usar con el palote, ejemplo: cat todo.log | wc -l => 16

> uptime: Muestra cuánto tiempo ha estado funcionando el sistema: hora, tiempo que lleva prendida, usuarios logeados y carga promedio en los últimos 5, 10 y 15 minutos (no sé en que medida pone esta carga)
Ejemplo de salida:
14:16  up 15 days,  2:56, 2 users, load averages: 3.27 2.83 2.48

> Sustitución de comandos:
Consiste en recuperar la salida de un comando en la línea de comandos. Las salidas de comandos pueden utilizarse para la asignación de una variable o como argumento de otro comando.
Fuente: https://www.ediciones-eni.com/open/mediabook.aspx?idR=a849d7c6bede7bcbd31416bbbf035a4b
Ejemplo 1:
echo "mi login es $(whoami)" => devuelve => mi login es marlorebazaloyola
- la utilidad “whoami” muestra el id del usuario:

Ejemplo 2:
echo "carpetas: $(ls /Users/$(whoami))" => devuelve:
carpetas: Adlm
AndroidStudioProjects
Applications
Desktop
Documents
…
- Explicación:
1. $(whoami) => devuelve => marlorebazaloyola
2. $(ls /Users/marlorebazaloyola) => devuelve => listado de archivos / directorios dentro de la carpeta /Users/marlorebazaloyola 
3. finalmente se imprime (por el uso de echo) el resultado del punto 2 con el texto prefijado “carpetas: “

> history:
Muestra los últimos 500 comandos ejecutados.

> ! : Permite realizar cosas como:
1. !50 : Ejecuta el comando en la posición 50 del historial (ver history)
2. !! : re-ejecuta el último comando
3. !ls : re-ejecuta el ultimo comando que comience con "ls"
4. !-3 : re-ejecuta el antepenultimo comando
5. Entre otras utilidades semejantes. Ver https://unix.stackexchange.com/a/3748

> grep: Busca dentro de un archivo o directorio dado, seleccionando las líneas que coinciden con el patrón(es) especificado
- “-r“: busca recursivamente en los sub-directorios
- “-e“: patrón de búsqueda
- “-n“: cada línea del resultado es precedida por el número de fila en el archivo
- “-v“: Invierte la selección. Selecciona las líneas que NO hagan match con cualquier patrón especificado

> find: Busca en la metadata de directorios y/o archivos
- “-name“: nombre.
- “-type”: tipo. Algunos valores posibles son: f=archivo, d=directorio, l=enlace simbolico
- “-size”: tamaño. “+”=mayor que, “-”=menor que, si no se indica nada será igual que. Algunos valores posibles son: c=bytes, k=kilobytes, M=megabytes… Si no se indica una medida lo indicado se multiplicará por 512 bytes. Por ejemplo si se indica 10 se considerará como 5120 bytes
- Ejemplo: listar los archivos cuyo nombre comienza con “ta” y tienen un tamaño mayor a 130 bytes: find . -type f -size +132c -name "ta*" 

> date: muestra o cambia la fecha y tiempo

> time: Imprime un resumen del tiempo de duración de ejecución de un determinado comando
Mas información: https://es.wikipedia.org/wiki/Time_(Unix)#Tiempo_de_usuario_vs._tiempo_de_sistema
- Tiempo real: tiempo transcurrido que tardó el comando en ejecutarse
- Tiempo de usuario: cantidad de segundos de CPU que ese comando usa en modo usuario
- Tiempo de sistema: cantidad de segundos de CPU que ese comando usa en modo kernel
Ejemplo: Mostrará el resumen del tiempo de ejecución del comando grep
- comando: time grep -r . -e a
- resultado: 
real	0m0.021s
user	0m0.005s
sys	0m0.007s

> curl: Transfiere data desde / hacia un servidor soportando diferentes protocolos (http, https, etc)
- “-#”: mostrará el progreso de la transferencia usando “#” como parte de la barra de progreso, en lugar del x defecto.
- “-o“: 
1. Escribe la salida en el archivo indicado:
curl https://www.adslzone.net/app/uploads-adslzone.net/2019/04/borrar-fondo-imagen-320x168.jpg -o myImage.jpg
2. Escribe la salida en el estándar output si se envía como valor un guión “-“:
curl https://www.adslzone.net/app/uploads-adslzone.net/2019/04/borrar-fondo-imagen-320x168.jpg -o -
3. Se puede indicar más de una vez por cada URL, el orden no importa:
curl -o first.png https://www.40defiebre.com/wp-content/uploads/2015/10/imagenes.png -o second.jpg https://www.adslzone.net/app/uploads-adslzone.net/2019/04/borrar-fondo-imagen-320x168.jpg
curl https://www.40defiebre.com/wp-content/uploads/2015/10/imagenes.png https://www.adslzone.net/app/uploads-adslzone.net/2019/04/borrar-fondo-imagen-320x168.jpg -o first.png -o second.jpg

> zip: Comprime los archivos indicados
zip todo.zip *
zip casi-todo.zip aeropuertos.csv first.png

> unzip: lista, prueba y extrae archivos comprimidos dentro de ZIP: 
unzip todo.zip
- “-v”: Lista los archivos (formato detallado) dentro del ZIP indicado si no se indica un ZIP mostrará la versión del comando unzip
- “-l”: Lista los archivos (formato corto) dentro del ZIP indicado

> tar: Manipula archivos: Empaqueta varios archivos en un solo, no los comprime. A menos que se combine con un programa de compresión, como gzip (opción “z”).
La ganancia de usar tar es que se evita usar el espacio en el sistema de archivos ya que encierra varios archivos en una sola “cinta”.
- “-x”: extrae archivos
- “-c”: crea un nuevo archivo conteniendo los archivos indicados (no es compresión)
- “-f”: lee el archivo o escribe sobre el archivo indicado
- “-z”: comprime usando gzip
- Ejemplos:
Crear cinta con todos los archivos: tar cf myFirstTape.tar *
Crear cinta comprimida con todos los archivos: tar cfz myFirstTape.tar.gz *
Listar contenido de cinta: tar tf myFirstTape.tar 
Descomprimir cinta con gzip: tar xfz myFirstTape.tar.gz
- .zip vs .tar.gz: 
1. zip: cada archivo es comprimido de manera independiente. 
desventaja: La compresión no aprovecha las similitudes de contenido entre los archivos contenidos.
ventaja: se puede acceder a cualquiera de los archivos contenidos
2. .tar.gz: 
desventaja: se debe desempaquetar todo el archivo (“cinta”) para acceder a los archivos contenidos dentro
ventaja: La compresión aprovecha las similitudes de contenido entre los archivos contenidos, ya que la compresión es sobre la “cinta”
Fuente: https://stackoverflow.com/a/10540952
Nota: 
Cabe mencionar que no es necesario usar el guión para indicar las opciones de tar. 
En caso se ejecute este comando: tar -cfz myFirstTape.tar.gs *, arrojará el error “tar: myfirsta.tar: Cannot stat: No such file or directory“, ya que toma “z” como la cinta donde se almacenarán los archivos “myFirstTape.tar.gs” y “*”.
Si se quiere ejecutar con guión se debe indicar la opción ”f” al último:
tar -czf myFirstTape.tar.gs *
Fuente: https://unix.stackexchange.com/a/149496



Fuente: https://www.enmimaquinafunciona.com/pregunta/26324/que-es-mas-eficiente---tar-o-zip-de-compresion-cual-es-la-diferencia-entre-el-tar-y-zip


> AWK: lenguaje de programación diseñado para procesar datos basados en texto, ya sean ficheros o flujos de datos: awk ‘SINTAXIS’
Sobre AWK: https://es.wikipedia.org/wiki/AWK
- “-F”: define el campo separador (field separator: fs) por línea. Puede ser una expresion regular
- print: imprimir texto
- printtf: imprimir texto forrajeado
- $#: “#” referencia al número de argumento de la línea actual. “$0”, se refiere a la línea entera. {printf($0)} imprimirá la línea entera.
Por ejemplo, Separar cada línea por la coma (“,”) e imprimir el segundo y tercer elemento de la separación y agregarle un salto de línea:
- cat data.csv | awk -F "," '{printf("Nombre: %s y Apellido: %s..\n", $2, $3)}'
- awk -F "," '{printf("Nombre: %s y Apellido: %s..\n", $2, $3)}' data.csv

> crontab: 
- cron: administrador y ejecutor de procesos en segundo plano (daemon=demonio) en intervalos de tiempo (cada minuto, día, semana o mes). 
Los procesos que deben ejecutarse y el momento en el que deben hacerlo se especifican en el fichero crontab.
- crontab: permite instalar, desinstalar y listar scripts/comandos que se ejecutaran en un tiempo especificado por el usuario. Cada usuario del sistema tiene su propio archivo crontab.
- “-l“: listar crontab’s
- “-e”: editar crontab’s
- En el archivo crontab se especifican 6 columnas: 
> minuto: 0 - 59
> hora: 0 - 23
> día del mes: 1 - 31
> día de la semana: 0 - 7 (0 y 7 son domingo) / o las primeras letras del nombre del día en ingles (con, que, wed, etc)
> comando o ruta absoluta del script que se quiere ejecutar
- comodines posibles para las columnas de tiempo (sin espacios en blanco):
> 1,10,18 (primer, décimo y decimoctavo)
> */5 (cada 5)
> 1-10 (todos los primeros 10)
> * (todos)
- Para escribir un comentario dentro del fichero crontab la línea debe comenzar con el caracter: “#”

> du: Muestra las estadísticas de uso de disco del archivo o directorio especificado. Si no se indica argumentos, mostrará los del directorio actual
- “-h”: salida “human-readable”. Usará los sufijos de unidades: Byte, Kilobyte, etc.
- “-d”: mostrará el uso de disco de los archivos y directorios hasta el nivel de profundidad indicado. Por ejemplo: 1 = directorios raíz, 2 = directorios raiz e hijos.
- Ejemplo de mostrar el uso de discos del directorio actual, sus directorios hijos y nietos:
du -h -d 2 

> ln: crea un enlace que apunta y tiene los mismos nodos que el archivo o directorio original. Permite mantener múltiples copias de un archivo en diferentes lugares sin usar almacenamiento. EL cómo un enlace apunta a un archivo o directorio es una diferencia entre enlace duro y simbólico.
- “-s”: crea un link simbólico
- Enlace duro vs simbolico
FUENTE: https://blog.usejournal.com/what-is-the-difference-between-a-hard-link-and-a-symbolic-link-8c0493041b62
> Enlace duro: 
Sólo se puede aplicar a un archivo. 
Dado que un enlace duro apunta al contenido del archivo, un cambio en cualquiera de estos. se reflejará en el otro (una ventaja sobre simplemente copiar un archivo).
Al eliminar el archivo origen, el enlace duro preserva el contenido del archivo.
Está enlazado al inodo (metadatos de un archivo: propietario, tamaño, fecha de creación, etc) del archivo origen
> Enlace simbólico: 
Puede aplicar a un directorio o archivo y remotos
Actua como un acceso directo.
Al eliminar el archivo origen, el enlace simbólico queda inutilizable
Está enlazado a otro nombre en el sistema de archivos
- Ejemplo creación de link simbolico
ln -s source source-link

> Permisos:
FUENTE: https://americandominios.com/conta/knowledgebase/627/Que-son-Los-permisos-777-755-700-664-666-y-CHMOD.html
- r: lectura
- w: escritura
- x: ejecución (si es un script)
- combinación = binario = decimal:
	rwx = 111 = 7
	rw- = 110 = 6
	-wx = 011 = 3
	r-x = 101 = 5
	r— = 100 = 4
	—— = 000 = 0
- chmod: modifica los permisos de un archivo o directorio
- Por ejemplo damos full permisos al propietario, lectura y escritura al grupo y ningún permiso al resto: chmod 740 task.py
- Diferencia de ejecutar un script con un interprete vs ejecutarlo directamente 
> Ejecución directa: Se espera que sea parseado con el shebang especificado, pero el SO espera que el usuario en cuestión tenga permiso de ejecución (“x”) sobre el script, sin importar el shebang.
> Ejecución con un interprete: Lo que se ejecuta es el interprete y se le envía como argumento el script. El archivo (script) no se ejecuta, por eso no se requiere permisos de ejecución. Obviamente el usuario en cuestión sí debe tener permiso de ejecución sobre el interprete.
FUENTE: https://stackoverflow.com/a/35865839

> sudo: Ejecuta el comando como un super-usuario. La password que se ingresa es la del usuario logeado, no la del usuario root.
Para lograr esto el usuario tendrá que estar ingresado en el fichero “sudoers”.
- sudo visudo: lanza un editor sobre el fichero “sudoers”
- agregar privilegios para un usuario: https://osxdaily.com/2014/02/06/add-user-sudoers-file-mac/

> “#!”: Conocido como “shebang”: La primera línea en un script que indica al interpretador de comandos (shell) que use el path especificado como interprete en lugar del por defecto.
Por ejemplo para indicar que un script se ejecute con java: 
“#!/usr/bin/java” 
También se pueden indicar argumentos: “#!/usr/bin/java -a -b …” 
Es posible tbn indicando el interprete desde las variables de ambiente: “#!/usr/bin/env java”, esta forma es más “portable” porque no se revela la ruta del bash, pero es un riesgo de seguridad ya que un malware desconocido podría ser ejecutado en lugar del interprete esperado. De esta forma no se pueden indicar argumentos al interprete.
Más detalle sobre bash vs env: https://unix.stackexchange.com/a/206366


PENDIENTES POR VER:
- sed
- stat => stat -f 'ACCESO: %Sa  MOD: %Sm  CREACION: %SB' numeros.txt   => No sé si es la fecha de acceso correcta
- set vs export vs env: NO entendí muy bien:
https://hackjutsu.com/2016/08/04/Difference%20between%20set,%20export%20and%20env%20in%20bash/
- eliminación con rm (va a la papelera?)